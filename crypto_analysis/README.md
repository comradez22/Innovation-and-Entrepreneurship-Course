# 				密码分析---以MeowHash为例

平台：Windows 

语言：C++ 

运行环境：VS2022，无额外依赖 

运行指南：在VS2022 Debug模式下直接运行即可

Author:张浩旸

日期：2022/7/29

成功运行截图：

构造堆成hash值：![对称](C:\Users\ASUS\Desktop\网安创新实践\密码分析\对称.png)

构造指定(消息-hash-key)三元组：

![构造](C:\Users\ASUS\Desktop\网安创新实践\密码分析\构造.jpg)



参考了这篇文章的讲解：

https://peter.website/meow-hash-cryptanalysis#differential-cryptanalysis

如何构造指定值：

meow hash中所有的操作都是可逆的，所以给定一个hash output和hash input 我们可以随机取7*128 个Lanes和hash output作为inverse函数的输入，然后倒退回原有的key值，根据文章的讲解我实现了一遍meow-hash，然后对我的名字-学号消息对（已经填充了）：

~~~c++
uint8_t HashInput[32] = { 0x5a ,0x68, 0x61, 0x6e, 0x67, 0x48, 0x61, 0x6f,
						0x59, 0x61, 0x6e, 0x67, 0x32, 0x30, 0x32, 0x30,
						0x30, 0x30, 0x34, 0x36, 0x30, 0x30, 0x39, 0x38,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };//ZhangHaoYang202000460098 padded
~~~

构造了一个key：

~~~c++
uint8_t InitKey[128] = { 0x99, 0x25, 0xae, 0xb4, 0x3b, 0x8f, 0xf2, 0xad, 0xb6, 0xa4, 0x97, 0x3b, 0x4, 0x26, 0x76, 0x66,
0x98, 0xf8, 0xab, 0x8, 0x2d, 0xb8, 0x96, 0x95, 0xf4, 0x97, 0xb3, 0xd0, 0x74, 0x57, 0xd2, 0x7c,
0x1d, 0xb3, 0xb6, 0x9, 0x26, 0xe2, 0x6e, 0x2a, 0xa0, 0x60, 0xa1, 0xd9, 0xee, 0xd, 0xaf, 0x20,
0x3c, 0x24, 0xf2, 0x6c, 0xdd, 0x71, 0xb3, 0x9b, 0xae, 0xe9, 0x8c, 0x48, 0x8f, 0x27, 0x54, 0xbe,
0x6e, 0xa1, 0xdc, 0x98, 0x87, 0x6b, 0x65, 0x2, 0x3c, 0xb9, 0xaf, 0x11, 0xcf, 0x1, 0x1, 0x4a,
0xd9, 0x9b, 0x42, 0xa0, 0x2f, 0xeb, 0x36, 0xb, 0xd3, 0x41, 0x9f, 0x8f, 0x95, 0x16, 0xce, 0x41,
0x3f, 0x24, 0x8c, 0x9c, 0xc1, 0xa1, 0x5, 0x92, 0x9c, 0x9c, 0x7d, 0x78, 0xad, 0x42, 0x9d, 0x84,
0x90, 0xbf, 0xe7, 0x40, 0x9e, 0xa2, 0x30, 0x41, 0x90, 0x70, 0x1f, 0xf6, 0x73, 0xaf, 0xc0, 0xbf, };
~~~

然后用这个key，进行一遍meow_hash，得到上图的结果，发现和指定的消息对是一样的。

我没有实现填充函数，因为所有的输入都是固定的，我构造好了Absorption函数的输入了，所以没有这个必要






